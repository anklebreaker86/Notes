# 第二章   计算机体系结构与CPU工作原理

嵌入式工程师除了要精通C语言编程，还要掌握

* 计算机原理和系统结构：可以更好地理解程序的编译、链接、安装和运行机制
* CPU工作原理：可以更好地理解指令到底是如何执行的
* ARM汇编语言：可以从底层的角度去看C语言，可以帮助我们更好地理解C语言
* 硬件电路



我们编写的C程序，最终都会转换成CPU所支持的二进制指令，而汇编语言又是这些指令集的助记符，通过反汇编代码，我们可以更加深刻地理解编译器的特性和C语言的语法



通过本章学习，对半导体工艺、芯片、CPU、指令集、微架构、计算机系统架构、总线与地址等有一个完整的认知框架



## 2.1 一颗芯片是怎样诞生的

芯片属于半导体

半导体是介于导体和绝缘体之间的一类物质



硅、锗、硒、硼等单质通过掺杂其他元素生成的一些化合物，也属于半导体的范畴

这些化合物在常温下可激发载流子的能力大增，导电能力大大增强，弥补了单质的一些缺点

目前只有硅在集成电路中大规模应用，充当着集成电路的原材料



1. **从沙子到单晶硅**

从沙子中提取单晶硅：

* 使用碳经过化学反应将二氧化硅还原成硅
* 经过还原反应生成的硅叫粗硅，粗硅里面包含很多杂质，需要进一步提纯
* 盐酸氯化、蒸馏等步骤提纯，提纯后生成的硅是多晶硅
* 将生成的多晶硅放入高温反应炉中融化，通过拉晶做出单晶硅棒
* 将这些单晶硅棒像切黄瓜一样，切成一片一片的，每一片我们称为晶圆（wafer）



为了增强硅的导电性能，一般会在多晶硅中掺杂一些硼元素或磷元素

晶圆是设计集成电路的载体，

晶圆上的每一个小格子都是一个芯片电路的物理实现，我们称之为晶粒（Die）



接下来还要对晶圆上的这些芯片电路进行切割、封装、引出管脚，然后就变成了市场上常见的芯片产品，最后才能焊接到我们的开发板上，做成整机产品



电路一般由大量的三极管、二极管、CMOS管、电阻、电容、电感、导线等组成

这些电子元器件的实现原理，其实就是PN结的实现原理。PN结是构成二极管、三极管、CMOS管等半导体元器件的基础



2. **PN结的工作原理**

金属的导电原理：一个原子由质子、中子和核外电子组成；中子不带电，质子带正电，核外电子带负电，整个原子显中性

根据电子的能级分布，一个原子的最外层电子数为8时最稳定



很多金属原子的最外层电子数小于4，容易丢失电子，称为自由移动的电子，所以金属容易导电，是导体

而对于氯原子，最外层有7个电子，倾向于从别处捕获一个电子，形成最外层8个电子的稳定结构，氯原子因为不能产生自由移动的电子，所以不能导电，是绝缘体



![image-20231005202419216](https://raw.githubusercontent.com/anklebreaker86/pictures/master/202310052024835.png)

半导体元素，一般最外层有4个电子，情况就变得比较特殊：这些原子之间往往通过“共享电子”的模式存在，多个原子之间分别共享其最外层的电子，通过共价键形成最外层8个电子的稳定结构



![image-20231005202550008](https://raw.githubusercontent.com/anklebreaker86/pictures/master/202310052025274.png)

这种稳定也不是绝对的，当这些电子受到能量激发时，也会有一部分发生跃迁，成为自由移动的电子，同时在共价键中留下同等数量的空穴

这些自由移动的电子虽然非常少，但是在电场的作用下，也会发生定向移动，形成电流

电子的移动产生了空穴，临近的电子也很容易跳过去填补这个空穴，产生一个新的空穴，造成空穴的移动

电子的移动产生了空穴，临近的电子也很容易跳过去填补这个空穴，产生一个新的空穴，造成空穴的移动



金属靠自由电子的移动产生电流导电，而半导体则有两种载流子：自由电子和空穴

但是由于硅原子比较稳定，只能生成极少数的自由电子和空穴，这就决定了硅无法像金属那样导电，但也不像绝缘体那样一点也不导电，因此我们称之为半导体



通过参杂增加这两种载流子的浓度：

* P型半导体：掺杂三价元素的半导体增加了空穴的浓度
* N型半导体：掺杂五价元素的半导体增加了自由电子的浓度



![image-20231005202943773](https://raw.githubusercontent.com/anklebreaker86/pictures/master/202310052029872.png)

我们在一块半导体的两边分别掺入不同的元素，使之成为不同的半导体

一边为P型，一边为N型；在两者的交汇处，就会形成一个特殊的界面，我们称之为PN结



![image-20231005205146895](https://raw.githubusercontent.com/anklebreaker86/pictures/master/202310052051027.png)

掺杂不同元素的半导体两边由于空穴和自由电子的浓度不同，因此在边界处会发生相互扩散：空穴和自由电子会分别越过边界，扩散到对方区域，并与对方区域里的自由电子、空穴在边界附近互相中和掉

P区边界处的空穴被扩散过来的自由电子中和掉后，剩下的都是不能自由移动的负离子，而在N区边界处留下的则是正离子。这些带电的正、负离子由于不能移动，就会在边界附近形成了耗尽层，同时会在这个区域内生成一个内建电场



这个内建电场会阻止P区的空穴继续向N区扩散，同时也会阻止N区的自由电子继续向P区扩散，空穴的扩散和自由电子的漂移从而达到一个新平衡，这个区域就是我们所说的PN结：载流子的移动此时已达到动态平衡，因此流过PN结的电流也变为0

这个PN结看起来也没什么，但它有一个特性：单向导电性



当我们在PN结两端加正向电压时，即P区接正极，N区接负极，此时就会削弱PN结的内建电场，平衡被打破，空穴和自由电子分别向两边扩散，形成电流，半导体呈导电特性

当我们在PN结两端加反向电压时，内建电场增强，此时会进一步阻止空穴和自由电子的扩散，不会形成电流，半导体呈现高阻特性，不导电



3. **从PN结到芯片电路**

无论二极管、三极管还是MOSFET场效应管，其内部都是基于PN结原理实现的

PN结实现的两个核心步骤：离子注入和光刻



离子注入其实就是掺杂，就是往单质硅中掺入三价元素硼和五价元素磷

光刻则是在晶圆上给离子注入开凿各种掺杂的窗口



在晶圆上进行离子注入掺杂之前，首先要根据电路版图制作一个个掺杂窗口

这一步需要光刻胶来协助完成：在硅衬底上涂上一层光刻胶，通过紫外线照射掩膜版，将电路图形投影到光刻胶上，生成一个个掺杂窗口，并将不需要掺杂的区域保护起来



产生掺杂窗口：使用感光胶片去洗照片一样，还需要一个叫作光刻掩膜版的东西

通过投影和曝光，我们可以将芯片的电路版图保存在掩膜版上

然后通过光刻机的紫外线照射，利用光刻胶的感光溶解特性，被电路图形遮挡的阴影部分的光刻胶保存下来，而被光照射的部分的光刻胶就会溶解，成为一个个掺杂窗口



最后通过离子注入，掺杂三价元素和五价元素，就会在晶圆的硅衬底上生成主要由PN结构成的各种CMOS管、晶体管电路



光刻机主要用来将你设计的电路图映射到晶圆上，通过光照将你设计的电路图形投影到光刻胶上，光刻胶中被电路遮挡的部分被保留，溶解的部分就是掺杂的窗口

晶体管越多，电路越复杂，工艺制程越先进，对光刻机的要求越高，因为需要非常精密地把复杂的电路图形投影到晶圆的硅衬底上



光刻机的作用是根据电路版图制作掩膜版，开凿各种掺杂窗口，然后通过离子注入，生成PN结，进而构建千千万万个元器件



4. **芯片的封装**

单纯的芯片电路无法直接焊接到硬件电路板上，还需要经过切割、封装、引出管脚、芯片测试等后续流程，测试通过后经过包装，才会变成市场上我们看到的芯片的样子



芯片的封装主要就是给芯片电路加一个外壳，引出管脚

常见的封装形式有DIP、QFP、BGA、CSP、MCM等



* DIP：指采用双列直插形式封装集成电路芯片，芯片有2排管脚，可以直接插到电路板上的芯片插座上，或者插到PCB电路板上穿孔焊接，非常方便

​		DIP一般适用于中小规模的集成电路芯片，芯片的管脚数比较少

​		常见的C51单片机、早期的8086 CPU都采用这种封装



* BGA：球栅阵列封装，使用BGA的芯片管脚不再从芯片周边引出，而是采用表面贴装型封装：在印刷基板的背面按照阵列方式制作出球形凸点来代替管脚，然后将芯片电路装配到基板的正面，最后用膜压树脂或灌封方法进行密封

​		BGA封装适用于CPU等管脚比较多的超大规模集成电路芯片



* CSP：芯片级封装，封装后的芯片尺寸更接近实际的芯片电路，通过CSP封装可以让芯片的封装面积和原来面积之比超过1：1.14，芯片封装的厚度也大大减小，从而缩减了芯片的体积，更适合高频电路的封装



* PoP：层叠封装，PoP可以将多个芯片元器件分层堆叠、互连，封装在一个芯片内，从而让整个芯片更薄、体积更小



## 2.2 一颗CPU是怎么设计出来的

1. **计算机理论基石：图灵机**

简单地理解为：任何复杂的运算都可以分解为有限个基本运算指令



不同架构的CPU，指令集不同，支持运行的机器指令也不同

但是有一条是相同的：每一种CPU只能支持有限个指令，任何复杂的运算最终都可以分解成有限个基本指令来完成：加、减、乘、除、与、或、非、移位等算术运算或逻辑运算



2. **CPU内部结构及工作原理**

CPU内部构造很简单，只包含基本的算术逻辑运算单元、控制单元、寄存器等，仅支持有限个指令

CPU支持的有限个基本指令集合，称为指令集

程序代码存储在内部存储器（内存）中，CPU可以从内存中一条一条地取指令、翻译指令并执行它



![image-20231005220900756](https://raw.githubusercontent.com/anklebreaker86/pictures/master/202310052209944.png)



* ALU：算术逻辑单元，是处理器最核心的部件，相当于CPU的大脑

​					ALU由算术单元和逻辑单元组成，算术单元主要负责数学运算，如加、减、乘							等；逻辑单元主要负责逻辑运算，如与、或、非等



ALU只是纯粹的运算单元，要想完成一个指令运行的整个流程，还需要控制单元的协助

控制单元根据程序计数器PC中的地址，会不断地从内存RAM中取指令，放到指令寄存器中并进行译码，将指令中的操作码和操作数分别送到ALU，执行相应的运算



CPU内部有个程序计数器（Program Counter，PC），系统上电后默认初始化为0，控制单元会根据这个PC寄存器中的地址到对应的内存RAM中取指令，然后PC寄存器中的地址自动加一



为了提高性能，防止RAM拖后腿，CPU一般都会在内部配置一些寄存器，用来保存CPU在计算过程中的各种临时结果和状态值





# 第三章   ARM体系结构与汇编语言

在嵌入式开发领域，ARM架构的处理器占了90%以上的市场份额



## 3.1 ARM体系结构

计算机的指令集一般可分为4种：

* 复杂指令集（CISC）
* 精简指令集（RISC）
* 显式并行指令集（EPIC）
* 超长指令字指令集（VLIW）



嵌入式学习中主要使用RISC，相对于CISC指令集，有以下特点：

*  Load/Store架构：CPU不能直接处理内存中的数据，要先将内存中的数据Load（加载）到寄存器中才能操作，然后将处理结果Store（存储）到内存中
* 固定的指令长度、单周期指令
* 倾向于使用更多的寄存器来存储数据，而不是使用内存中的堆栈，效率更高



ARM的RISC指令集，与原RISC指令集区别：

* ARM有桶型移位寄存器，单周期内可以完成数据的各种移位操作
* 并不是所有的ARM指令都是单周期的
* ARM有16位的Thumb指令集，是32位ARM指令集的压缩形式，提高了代码密度
* ARM有16位的Thumb指令集，是32位ARM指令集的压缩形式，提高了代码密度
* 增加了DSP、SIMD/NEON等指令



ARM处理器有多种工作模式

应用程序正常运行时，ARM处理器工作在用户模式（User mode）

当程序运行出错或有中断发生时，ARM处理器就会切换到对应的特权工作模式



|   处理器模式    |               模式介绍                |
| :-------------: | :-----------------------------------: |
|    User mode    |        程序正常运行时工作模式         |
|    FIQ mode     |             快速中断模式              |
|    IRQ mode     |               中断模式                |
| Supervisor mode | 管理模式，保护模式，复位和软中断进入  |
|   Abort mode    |   数据存取异常、指令读取失败会进入    |
| Undefined mode  | CPU遇到无法识别、未定义指令时，会进入 |
|   System mode   |   类似用户模式，但可运行特权OS任务    |
|  Monitor mode   |            仅限于安全扩展             |



应用程序正常运行时，处理器处于普通模式，没有权限对内存和底层硬件进行操作

要首先通过系统调用或软中断进入处理器特权模式，运行操作系统内核或硬件驱动代码，才能对底层的硬件设备进行读写操作



在ARM处理器内部，寄存器：

* 算术运算单元
* 逻辑运算单元
* 浮点运算单元
* 控制单元
* 通用寄存器
* 状态寄存器
* 控制寄存器

控制处理器的运行，保存程序运行时的各种状态和临时结果



ARM处理器中的寄存器可分为==通用寄存器==和==专用寄存器==两种

寄存器R0～R12属于通用寄存器，除了FIQ工作模式，在其他工作模式下这些寄存器都是共用、共享的：

* R0～R3通常用来传递函数参数
* R4～R11用来保存程序运算的中间结果或函数的局部变量等
* R12常用来作为函数调用过程中的临时寄存器



还有一些寄存器在各自的工作模式下是独立存在的，如R13、R14、R15、CPSP、SPSR寄存器，在每个工作模式下都有自己单独的寄存器

* R13寄存器又称为堆栈指针寄存器（Stack Pointer，SP），用来维护和管理函数调用过程中的栈帧变化，R13总是指向当前正在运行的函数的栈帧，一般不能再用作其他用途
* R14寄存器又称为链接寄存器（Link Register，LR），在函数调用过程中主要用来保存上一级函数调用者的返回地址
* 寄存器R15又称为程序计数器（Program Counter，PC），CPU从内存取指令执行，就是默认从PC保存的地址中取的，每取一次指令，PC寄存器的地址值自动增加



PC指针的值等于当前正在运行的指令地址+8



当前处理器状态寄存器（Current Processor State Register，CPSR）主要用来表征当前处理器的运行状态，其中具有状态位、标志位和控制位



在每种工作模式下，都有一个单独的程序状态保存寄存器（Saved Processor State Register，SPSR）

当ARM处理器切换工作模式或发生异常时，SPSR用来保存当前工作模式下的处理器现场，即将CPSR寄存器的值保存到当前工作模式下的SPSR寄存器

从异常返回时，可切换回原先工作模式



在ARM所有的工作模式中，有一种工作模式比较特殊，即FIQ模式

为了快速响应中断，减少中断现场保护带来的时间开销，在FIQ工作模式下，ARM处理器有自己独享的R8～R12寄存器



## 3.2 ARM汇编指令

一个完整的ARM指令通常由==操作码==+==操作数==组成，指令的编码格式如下

```c
<opcode> {<cond> {s} <Rd>,<Rn> {,<operand2>}}
```



格式具体说明：

* 使用<>标起来的是必选项，使用{}标起来的是可选项
* <opcode>是二进制机器指令的操作码助记符，如MOV、ADD这些汇编指令都是操作码的指令助记符
* cond：执行条件，ARM为减少分支跳转指令个数，允许类似BEQ、BNE等形式的组合指令
* S：是否影响CPSR寄存器中的标志位，如SUBS指令会影响CPSR寄存器中的N、Z、C、V标志位，而SUB指令不会
* Rd：目标寄存器
* Rn：第一个操作数的寄存器
* operand2：第二个可选操作数，灵活使用第二个操作数可以提高代码效率



1. **存储访问指令**











