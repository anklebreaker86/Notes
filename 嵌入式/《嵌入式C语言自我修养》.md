# 第一章   工欲善其事必先利其器

## 1.1 代码编辑工具Vim

Vim是一款纯命令行操作、功能可扩展、高度可定制的文本编辑工具



1. **安装Vim**

在Ubuntu环境下安装Vim

```c
# apt-get install vim
sudo apt-get install vim
```



查看vim版本号

```
vim -v
```



2. **常用命令**

常见工作模式：

* 普通模式：打开文件时的默认模式，在其他模式下按下ESC键都可返回到该模式
* 插入模式：按i/o/a键进入该模式，进行文本编辑操作，不同之处在于插入字符的位置在光标之前还是之后
* 命令行模式：普通模式下输入冒号（：）后会进入该模式，在该模式下输入命令，如输入：set number或：set nu可以显示行号
* 可视化模式：在普通模式下按v键会进入可视化模式。在该模式下移动光标可以选中一块文本，然后可以进行复制、剪切、删除、粘贴等文本操作
* 替换模式：在普通模式下通过光标选中一个字符，然后按r键，再输入一个字符，你会发现你输入的字符就替换掉了原来那个被选中的字符



单个字符移动：

* k：光标上移一个字符
* j：光标下移一个字符
* h：左移
* l：光标右移



单词移动：

* w：移动到下一个单词开头

* b：上一个单词开头

* e：下一个单词词尾

* ge：上一个单词词尾



行移动：

* $：移动到当前行行尾
* 0：移动到当前行的行首
* ^：移动到当前行的第一个非空字符
* 2|：移动到当前行的第2列
*  fx：移动到当前行的第1个字符x上
* %：符号间的移动，在()、[]、{}之间跳跃



屏幕移动：

* nG：光标跳转到指定的第n行

* gg/G：光标跳转到文件的开头/末尾

* M：光标移动到当前屏幕的中间

* L：光标移动到当前屏幕的末尾

* Ctrl+g：光标查看当前的位置状态

* Ctrl+u/d：光标向前/后半屏滚动

* Ctrl+f/b：光标向前/后全屏滚动

  

















# 第二章   计算机体系结构与CPU工作原理

嵌入式工程师除了要精通C语言编程，还要掌握

* 计算机原理和系统结构：可以更好地理解程序的编译、链接、安装和运行机制
* CPU工作原理：可以更好地理解指令到底是如何执行的
* ARM汇编语言：可以从底层的角度去看C语言，可以帮助我们更好地理解C语言
* 硬件电路



我们编写的C程序，最终都会转换成CPU所支持的二进制指令，而汇编语言又是这些指令集的助记符，通过反汇编代码，我们可以更加深刻地理解编译器的特性和C语言的语法



通过本章学习，对半导体工艺、芯片、CPU、指令集、微架构、计算机系统架构、总线与地址等有一个完整的认知框架



## 2.2 一颗CPU是怎么设计出来的

1. **计算机理论基石：图灵机**

现代计算机理论的技术源头可以追溯到几十年前的图灵机

简单地理解为：任何复杂的运算都可以分解为有限个基本运算指令



图灵机：一条无限长的纸带Tape、一个读写头Head、一套控制规则Table、一个状态寄存器

图灵机内部有一个机器读写头Head，读写头可以一直读取纸带，图灵机根据自己有限的控制规则，根据纸带的输入，不断更新机器的状态，并将输出打印到纸带上

![image-20240119171340666](https://raw.githubusercontent.com/anklebreaker86/pictures/master/202401191713455.png)



* 无限长的纸带：相当于程序代码
* 读写头Head：相当于程序计数器PC
* 一套控制规则Table：相当于CPU有限的指令集
* 一个状态寄存器：相当于程序或计算机的状态输出



不同架构的CPU，指令集不同，支持运行的机器指令也不同

但是有一条是相同的：每一种CPU只能支持有限个指令，任何复杂的运算最终都可以分解成有限个基本指令来完成：加、减、乘、除、与、或、非、移位等算术运算或逻辑运算



2. **CPU内部结构及工作原理**

CPU内部构造很简单，只包含基本的算术逻辑运算单元、控制单元、寄存器等，仅支持有限个指令

CPU支持的有限个基本指令集合，称为指令集

程序代码存储在内部存储器（内存）中，CPU可以从内存中一条一条地取指令、翻译指令并执行它

![image-20231005220900756](https://raw.githubusercontent.com/anklebreaker86/pictures/master/202310052209944.png)



* 算术逻辑单元（ALU）：是处理器最核心的部件，相当于CPU的大脑
  * ALU由算术单元和逻辑单元组成，算术单元主要负责数学运算，如加、减、乘等；逻辑单元主要负责逻辑运算，如与、或、非等
  * ALU只是纯粹的运算单元，要想完成一个指令运行的整个流程，还需要控制单元的协助
* 控制单元：控制单元根据程序计数器PC中的地址，会不断地从内存RAM中取指令，放到指令寄存器中并进行译码，将指令中的操作码和操作数分别送到ALU，执行相应的运算
  * 例如，整数A和B相加
  * 控制单元通过指令译码电路会将该指令分解为操作码和操作数，再根据操作数地址从内存RAM中加载（Load）数据A和B，传送到ALU的输入端，然后将操作运算类型（操作码）即加法也告诉ALU
  * ALU有了输入数据和操作类型，就可以直接进行相应的运算了，并输出运算结果
  * 为了效率考虑，运算结果一般会先保存到寄存器中，然后由控制单元将该数据从寄存器存储（Store）到内存RAM中
* 程序计数器（PC）：系统上电后默认初始化为0，控制单元会根据这个PC寄存器中的地址到对应的内存RAM中取指令，然后PC寄存器中的地址自动加一



早期CPU的工作频率和内存RAM相比，差距较大

控制单元从RAM中加载数据到CPU，或者将CPU内部的数据存储到RAM中，一般要经过多个时钟读写周期才能完成











# 第三章   ARM体系结构与汇编语言

在嵌入式开发领域，ARM架构的处理器占了90%以上的市场份额



## 3.1 ARM体系结构

计算机的指令集一般可分为4种：

* 复杂指令集（CISC）
* 精简指令集（RISC）
* 显式并行指令集（EPIC）
* 超长指令字指令集（VLIW）



嵌入式学习中主要使用RISC，相对于CISC指令集，有以下特点：

*  Load/Store架构：CPU不能直接处理内存中的数据，要先将内存中的数据Load（加载）到寄存器中才能操作，然后将处理结果Store（存储）到内存中
* 固定的指令长度、单周期指令
* 倾向于使用更多的寄存器来存储数据，而不是使用内存中的堆栈，效率更高



ARM的RISC指令集，与原RISC指令集区别：

* ARM有桶型移位寄存器，单周期内可以完成数据的各种移位操作
* 并不是所有的ARM指令都是单周期的
* ARM有16位的Thumb指令集，是32位ARM指令集的压缩形式，提高了代码密度
* ARM有16位的Thumb指令集，是32位ARM指令集的压缩形式，提高了代码密度
* 增加了DSP、SIMD/NEON等指令



ARM处理器有多种工作模式

应用程序正常运行时，ARM处理器工作在用户模式（User mode）

当程序运行出错或有中断发生时，ARM处理器就会切换到对应的特权工作模式



|   处理器模式    |               模式介绍                |
| :-------------: | :-----------------------------------: |
|    User mode    |        程序正常运行时工作模式         |
|    FIQ mode     |             快速中断模式              |
|    IRQ mode     |               中断模式                |
| Supervisor mode | 管理模式，保护模式，复位和软中断进入  |
|   Abort mode    |   数据存取异常、指令读取失败会进入    |
| Undefined mode  | CPU遇到无法识别、未定义指令时，会进入 |
|   System mode   |   类似用户模式，但可运行特权OS任务    |
|  Monitor mode   |            仅限于安全扩展             |



应用程序正常运行时，处理器处于普通模式，没有权限对内存和底层硬件进行操作

要首先通过系统调用或软中断进入处理器特权模式，运行操作系统内核或硬件驱动代码，才能对底层的硬件设备进行读写操作



在ARM处理器内部，寄存器：

* 算术运算单元
* 逻辑运算单元
* 浮点运算单元
* 控制单元
* 通用寄存器
* 状态寄存器
* 控制寄存器

控制处理器的运行，保存程序运行时的各种状态和临时结果



ARM处理器中的寄存器可分为==通用寄存器==和==专用寄存器==两种

寄存器R0～R12属于通用寄存器，除了FIQ工作模式，在其他工作模式下这些寄存器都是共用、共享的：

* R0～R3通常用来传递函数参数
* R4～R11用来保存程序运算的中间结果或函数的局部变量等
* R12常用来作为函数调用过程中的临时寄存器



还有一些寄存器在各自的工作模式下是独立存在的，如R13、R14、R15、CPSP、SPSR寄存器，在每个工作模式下都有自己单独的寄存器

* R13寄存器又称为堆栈指针寄存器（Stack Pointer，SP），用来维护和管理函数调用过程中的栈帧变化，R13总是指向当前正在运行的函数的栈帧，一般不能再用作其他用途
* R14寄存器又称为链接寄存器（Link Register，LR），在函数调用过程中主要用来保存上一级函数调用者的返回地址
* 寄存器R15又称为程序计数器（Program Counter，PC），CPU从内存取指令执行，就是默认从PC保存的地址中取的，每取一次指令，PC寄存器的地址值自动增加



PC指针的值等于当前正在运行的指令地址+8



当前处理器状态寄存器（Current Processor State Register，CPSR）主要用来表征当前处理器的运行状态，其中具有状态位、标志位和控制位



在每种工作模式下，都有一个单独的程序状态保存寄存器（Saved Processor State Register，SPSR）

当ARM处理器切换工作模式或发生异常时，SPSR用来保存当前工作模式下的处理器现场，即将CPSR寄存器的值保存到当前工作模式下的SPSR寄存器

从异常返回时，可切换回原先工作模式



在ARM所有的工作模式中，有一种工作模式比较特殊，即FIQ模式

为了快速响应中断，减少中断现场保护带来的时间开销，在FIQ工作模式下，ARM处理器有自己独享的R8～R12寄存器



## 3.2 ARM汇编指令

一个完整的ARM指令通常由==操作码==+==操作数==组成，指令的编码格式如下

```c
<opcode> {<cond> {s} <Rd>,<Rn> {,<operand2>}}
```



格式具体说明：

* 使用<>标起来的是必选项，使用{}标起来的是可选项
* <opcode>是二进制机器指令的操作码助记符，如MOV、ADD这些汇编指令都是操作码的指令助记符
* cond：执行条件，ARM为减少分支跳转指令个数，允许类似BEQ、BNE等形式的组合指令
* S：是否影响CPSR寄存器中的标志位，如SUBS指令会影响CPSR寄存器中的N、Z、C、V标志位，而SUB指令不会
* Rd：目标寄存器
* Rn：第一个操作数的寄存器
* operand2：第二个可选操作数，灵活使用第二个操作数可以提高代码效率



1. **存储访问指令**











