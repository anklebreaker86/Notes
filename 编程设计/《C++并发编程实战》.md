





# 第三章   在线程间共享数据

## 3.1 线程间共享数据的问题

多线程共享数据的问题多由数据改动引发，如果所有共享数据都是只读数据，就不会有问题

并发代码中一种最常见的错误成因：条件竞争（race condition）



1. **条件竞争**

在并发编程中，操作由两个或多个线程负责，它们争先让线程执行各自的操作，而结果取决于它们执行的相对次序，所有这种情况都是条件竞争



C++标准还定义了术语“数据竞争”（data race）：并发改动单个对象而形成的特定的条件竞争



诱发恶性条件竞争的典型场景是，要完成一项操作，却需改动两份或多份不同的数据



2. **防止恶性条件竞争**

有几种方法防止恶性条件竞争：

* 采取保护措施包装数据结构，确保不变量被破坏时，中间状态只对执行改动的线程可见
* 修改数据结构的设计及其不变量，由一连串不可拆分的改动完成数据变更，每个改动都维持不变量不被破坏，称为无锁编程
* 将修改数据结构当作事务（transaction）来处理，类似于数据库在一个事务内完成更新：把需要执行的数据读写操作视为一个完整序列，先用事务日志存储记录，再把序列当成单一步骤提交运行



# 3.2 用互斥保护共享数据

运用名为互斥（mutual exclusion，略作mutex）的同步原语（synchronization primitive）就能达到只要有线程正在运行标记的代码，任何别的线程意图访问同一份数据，则必须等待，直到该线程完事的效果



访问一个数据结构前，先锁住与数据相关的互斥；访问结束后，再解锁互斥

互斥本身也有问题，表现形式是死锁



1. **在C++中使用互斥**

在C++中，我们通过构造std::mutex的实例来创建互斥，调用成员函数lock()对其加锁，调用unlock()解锁



不推荐直接调用成员函数的做法

原因是，若按此处理，那我们就必须记住，在函数以外的每条代码路径上都要调用unlock()，包括由于异常导致退出的路径



取而代之，C++标准库提供了类模板std::lock_guard<>

在构造时给互斥加锁，在析构时解锁，从而保证互斥总被正确解锁



```c++
#include <list>
#include <mutex>
#include <algorithm>




```































