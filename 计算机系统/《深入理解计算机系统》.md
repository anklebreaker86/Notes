# 第一章   计算机系统漫游

计算机系统由硬件和系统软件组成



## 1.1 信息就是位 + 上下文

源程序hello.c实际上是由值0和1组成的位序列

8个位为一组，称为字节，每个字节表示一个字符



系统中的所有信息：包括磁盘文件、内存中的程序、内存中存放的用户数据等都是由一串比特表示的

区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文



## 1.2 程序被其他程序翻译成不同格式

hello.c被转换为低级机器语言指令，这些指令按照可执行目标程序的格式打包，存为二进制文件

有四个阶段，执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成编译系统



* 预处理阶段：根据#开头命令，修改hello.c程序，得到hello.i
* 编译阶段：将hello.i翻译成hello.s，包含一个汇编语言程序
* 汇编阶段：将hello.s翻译成机器语言指令，把这些指令打包成可重定位目标程序格式，并将结果保存在目标文件hello.o中
* 链接阶段：当调用别的目标文件函数时，链接器负责将该文件合并到hello.o中，结果得到hello文件，可执行目标文件



## 1.3 了解编译系统如何工作的益处

知道编译系统如何工作的益处：

* 优化程序性能
* 理解链接时出现的错误
* 避免安全漏洞



## 1.4 处理器读并解释储存在内存中的指令

hello.c被编译成可执行文件hello，存放在磁盘上

在Unix上运行，将文件名输入到shell中

```c++
linux> ./hello
```



1. **系统的硬件组成**

* 总线：贯穿整个系统的电子管道，携带字节在各部件间传递。总线传送定长的字节块，即字。大多数字长要么是4字节（32位），要么是8个字节（64位）
* I/O设备：IO是系统与外部的联系通道。每个I/O设备都通过一个==控制器==或==适配器==与I/O总线相连。控制器与适配器功能相同，区别在于控制器是主板上的芯片组，适配器是插在主板插槽上的卡
* 主存：临时存储设备，处理器执行程序时，存放程序和程序处理的数据。物理上，主存是一组动态随机存取存储器芯片组成；逻辑上，是一个线性的字节数组
* 处理器：存储器核心是大小为一个字的寄存器，称为程序计数器，指向主存中某条机器语言指令。CPU不断执行程序计数器指向指令。算数逻辑单元ALU计算新的数据和地址值



CPU会执行以下操作：

* 加载：从主存复制一个字节或一个字到寄存器，覆盖寄存器原来内容
* 存储：与加载相反
* 操作：把两个寄存器内容复制到ALU，ALU对这两个字做算数运算，将结果存到一个寄存器中，覆盖原来内容
* 跳转：从指令本身抽取一个字，并将这个字复制到程序计数器中，覆盖原来的值



2. **运行hello程序**

* 输入 ./hello后，shell将字符读入寄存器，存到内存中
* 敲击回车后，加载hello文件，将hello目标文件中代码和数据从磁盘复制到主存
* 代码和数据加载到主存后，处理器开始执行hello程序。将"hello world"从主存复制到寄存器文件，再复制到显示设备



## 1.5 高速缓存至关重要

复制就是开销，减慢了程序的正常工作

较大的存储设备要比较小的存储设备运行得慢，快速设备造价远高于同类低速设备

处理器从寄存器文件中读数据比从主存中读取几乎快100倍，为针对这种差异，系统设计者采用了更小更快的存储设备，称为==高速缓存存储器==



L1、L2高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的



## 1.6 存储设备形成层次结构

在每个计算机系统中的存储设备都被组织成了一个存储器结构

从上到下，访问速度越来越慢，容量越来越大



* L0：寄存器
* L1：L1高速缓存（SRAM）
* L2：L2高速缓存（SRAM）
* L3：L3高速缓存（SRAM）
* L4：主存（DRAM）
* L5：本地二级存储（本地磁盘）
* L6：远程二级存储（分布式文件系统，web服务器）



## 1.7 操作系统管理硬件

操作系统是硬件和应用程序之间插入的一层软件，所有应用程序对硬件的操作都必须通过操作系统

操作系统的两个基本功能：

* 防止硬件被失控的应用程序滥用
* 向应用程序提供一致的机制来来控制复杂而又通常大不相同的低级硬件设备



操作系统通过几个基本的抽象概念来实现这两个功能：

* 进程
* 虚拟内存
* 文件



1. **进程**

进程是操作系统对一个正在运行的程序的一种抽象

一个CPU看上去是在并发执行多个进程，这是通过处理器在进程间切换实现的，称为上下文切换



上下文包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容

从一个进程到另一个进程的转换是由操作系统==内核（kernel）==管理的



2. **线程**

一个进程实际上可以由多个线程组成，每个线程都运行在进程的上下文中，共享同样的代码和全局数据



3. **虚拟内存**

为每个进程提供一个假象，即每个进程都在独占地使用主存

每个进程看到的内存是一致的，称为虚拟地址空间



![image-20230924172337617](https://raw.githubusercontent.com/anklebreaker86/pictures/master/202309241723018.png)

地址空间最上面区域是保留给操作系统中的代码和数据的

地址空间的底部存放用户进程定义的代码和数据

地址从下往上增大



每个进程看到的虚拟空间由大量准确定义的区构成，每个区都有专门功能：

* 程序代码和数据：对所有进程来说，代码是从同一固定地址开始，紧接着是数据位置，直接按照可执行目标文件内容初始化
* 堆：代码和数据区一开始就指定大小。调用malloc和free时，堆可以动态地变化
* 共享库：存放像C标准库和数学库这样地共享库代码和数据
* 栈：编译器用栈来实现函数调用，也可以动态变化。调用函数栈会增长；从函数返回，栈会收缩
* 内核虚拟内存：不允许应用程序使用该区域，调用内核。



4. **文件**

文件就是字节序列

每个IO设备，如磁盘、键盘、网络等，都可以看成是文件



## 1.8 系统之间利用网络通信

现代系统经常通过网络和其他系统连接到一起

从一个单独的系统来看，网络可视为一个IO设备

数据从主存复制到网络适配器，经过网络到达另一台机器



## 1.9 重要主题

1. **Amdahl定律**

对系统某部分加速时，其对系统整体性能影响取决于该部分的重要性和加速程度



设执行某程序时间$T_{old}$，假设某部分执行时间与该时间比例为α，该部分性能提升比例为k，即初始所需时间$αT_{old}$，现在为$αT_{old}/k$

因此总执行时间：$T_{new}=(1-α)T_{old}+(αT_old)/k=T_{old}[(1-α)+α/k]$

由此计算加速比为：$S=T_{old}/T_{new}$

​																$S=\frac{1}{(1-α)+α/k}$



要想显著加速整个系统，必须提升全系统中相当大的部分的速度



2. **并发和并行**

并发：concurrency，指一个同时具有多个活动的系统

并行：parallelism，指用并发使一个系统运行得更快



* 线程级并发

传统意义上，这种并发执行是模拟出来得，是一台计算机在进程间快速切换，这种配置称为单处理器系统

多核处理器将多个CPU集成到一个芯片上，减少执行多任务时模拟并发的需要



超线程是允许一个CPU执行多个控制流的技术，处理器可以决定执行哪一个线程

比如，一个线程必须等到某个数据被装载到高速缓存中，那CPU就可以去执行另一个线程



多处理器从两方面提高系统性能：

1. 减少了在执行多个任务时模拟并发的需要

2. 可以使应用程序运行得更快，这需要程序是以多线程方式来书写的



* 指令级并行

可以同时执行多条指令的属性称为指令级并行

如果处理器可以达到比一周期一条指令更快的执行速率，就称之为超标量处理器



* 单指令、多数据并行

许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行



3. **计算机中抽象的重要性**

操作系统中有三个抽象：文件、虚拟内存、进程

再增加一个新的抽象：虚拟机，提供对整个计算机的抽象，包括操作系统、处理器和程序



# 第二章   信息的表示和处理

计算机存储和处理信息以二值信号表示，称为位（bit）



三种重要数字表示：

* 无符号（unsigned）编码
* 补码（two's-complement）
* 浮点数（floating-point）编码



计算机用有限位对一个数字编码，因此结果太大不能表示时，会溢出（overflow）



整数表示只能编码一个较小数值范围，但表示是精确的；浮点数表示是近似的



## 2.1 信息存储

使用8位的块，即字节（byte）作为最小的可寻址的内存单位，而不是访问单独的位



机器级程序将内存视为一个非常大的字节数组，称为虚拟内存（virtual memory）

每个字节由一个唯一数字标识，称为地址（address）

所有可能地址集合称为虚拟地址空间（virtual address space）



1. **十六进制表示法**

0x或0X开头数字常量被认为是十六进制的值



2. **字数据大小**

每台计算机都有一个字长（word size），指明指针数据的标称大小（nominal size）

虚拟地址以这样一个字来编码，字长决定最重要参数是虚拟空间最大大小。即，对字长为w位的机器而言，虚拟地址范围为0~$2^{w-1}$。



大多数64位机器可以运行32位机器编译的程序，反之不行

```c++
linux> gcc -m32 prog.c
linux> gcc -m64 prog.c
```



有些数据类型的确切字节数依赖于程序是如何被编译的

为避免依赖典型大小和不同编译器设置带来的奇怪行为，C99引入了一类大小固定的数据类型，如int32_t和int64_t分别为4字节和8个字节

可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感



3. **寻址和字节顺序**

如何跨越多字节的程序对象，必须建立两个规则：

* 这个对象的地址是什么
* 在内存中如何排列这些字节



多字节对象被存储为连续的字节序列，对象地址为所使用字节中最小的地址

例如，int型变量x的地址为0x100，即&x的值为100。那么x的4个字节被存储在0x100、0x101、0x102和0x103位置



考虑一个w位整数，其位表示为[$x_{w-1}$,$x_{w-2}$,...,$x_1$,$x_0$]，其中$x_{w-1}$是最高有效位，而$x_0$是最低有效位

假设w是8的倍数，这些位就能被分组成为字节



排列这些字节有两个规则：

* ==小端法==：在内存中按照从最低有效字节到最高有效字节的顺序存储对象
* ==大端法==：按照从最高有效字节到最低有效字节的顺序存储



假设x类型为int，地址为0x100，十六进制值0x01234567，字节顺序为：

![image-20230926230411554](https://raw.githubusercontent.com/anklebreaker86/pictures/master/202309262304655.png)

















