# 第三章   Java的基本程序设计结构

## 3.1 一个简单的Java应用程序

```java
public class FirstSample
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
}
```



Java区分大小写。

源代码的文件名必须与公共类名字相同，并用.java作为扩展名。

每个Java应用程序都必须要有一个main方法。



## 3.2 注释

有三种标记注释的方法：

* 使用//
* 使用 /* 和*/
* 可以自动生成注释文档，/** 和 */



## 3.3 数据类型

在Java中，有8中基本类型，其中4种整型，2种浮点型，1种表示Unicode的char型，一种boolean型。



1. **整型**

允许负数。

| 类型  | 存储  |
| :---: | :---: |
| byte  | 1字节 |
| short | 2字节 |
|  int  | 4字节 |
| long  | 8字节 |



长整型数值有后缀L，十六进制有前缀0x，八进制有前缀0，二进制前缀为0b。



2. **浮点类型**

|  类型  | 存储  |
| :----: | :---: |
| float  | 4字节 |
| double | 8字节 |



绝大部分程序采用double。

float类型有后缀F，没有后缀默认为double。



三个特殊浮点数值：

* 正无穷大Double.POSITIVE_INFINITY
* 负无穷大Double.NEGATIVE_INFINITY
* 不是数字NaN，Double.NaN



3. **char类型**

原本表示单个字符，如今有些Unicode字符需要两个char值。

char类型字面量用单引号括起来，还有一些表示特殊字符的转义序列。

| 转义序列 |  名称  |
| :------: | :----: |
|    \b    |  退格  |
|    \t    |  制表  |
|    \n    |  换行  |
|    \r    |  回车  |
|   \ "    | 双引号 |
|   \ '    | 单引号 |
|   \ \    | 反斜杠 |



16位的char不能满足需要，使用码点。



5. **boolean类型**

布尔型有false和true，整型值和布尔值之间不能互相转换。



## 3.4 变量

每个变量都有一个类型，声明变量时，位于变量名之前。



1. **变量初始化**

声明变量后，需要用赋值语句对变量进行初始化，不要使用未初始化的变量。

变量声明尽可能靠近第一次使用的地方。



2. **常量**

利用关键字final标记常量，表示该变量只能赋值一次。

类常量使用==static final==设置。

```java
public class Constant
{
    public static final double CM_PER_INCH = 2.54;
    
    public static void main(String[] args)
    {
        ......
    }
}
```



## 3.5 运算符

加减乘除+-*/

除法两个操作数都是整数时表示整数除法，否则为浮点数除法。

求余操作使用%



1. **数学函数与常量**

Math类中，包含各种数学函数。

如sqrt、pow、floorMod、sin、cos、tan、atan、atan2、exp、log、log10

Math.PI和Math.E



2. **数值类型之间的转换**

![1668685661437](D:\数据\typora图\1668685661437.jpg)



实心箭头表示无信息丢失转换；虚线箭头表示可能有精度损失的转换。

使用二元操作时，需要将两个操作数转换为同一类型再进行操作。

* 有一个是double，另一个就会转成double
* 否则，有一个是float，另一个就会转成float
* 否则，有一个是long，另一个就会转成long
* 否则，都转成int



3. **强制类型转换**

强制类型转换：

```java
double x = 9.997;
int nx = (int)x;
nx = (int)Math.round(x); //对浮点数舍入运算
```



4. **结合赋值和运算符**

x += 4;



5. **自增与自减**

n++和++n，前缀会先完成加1，后缀会使用变量原来的值。



6. **关系和boolean运算符**

==检测相等性，!=检测不等性，还有<、>、<=、>=

！是逻辑非，&&和||按照短路方式求值。

三元操作符  condition ? expression1 ：expression2，条件为true就被第一个表达式的值，否则为第二个。



7. **位运算符**

位运算包括：&、|、^(异或)、~(取反)

​	>>和<<将位模式左移或右移，>>>用符号位填充高位。



8. **括号和运算符级别**

同一级别运算符从左到右次序进行计算，除非为右结合运算符。



9. **枚举类型**

枚举类型包括有限个命名的值，枚举变量只能存储枚举值或null。

```java
enum Size {SMALL, MEDIUM, LARGE, EXTRA_LARGE};
Size s = Size.MEDIUM;
```



## 3.6 字符串

Java没有内置字符串类型，而是提供一个String类。

每个用双引号括起来的字符串都是String类的一个实例。



1. **子串**

String类的substring方法可以从字符串中提取出一个子串

```java
String greeting = "Hello";
String s = greeting.substring(0, 3); // s = "Hel"
```

第一个参数为复制起点，第二个参数为不想复制的第一个位置。



2. **拼接**

Java允许用+号连接两个字符串。

将一个字符串和一个非字符串的值进行拼接时，后者被转换为字符串。

若需要用定界符分隔多个字符串，可以使用静态join方法：

```java
String all = String.join("/", "S", "M", "L"); //结果为"S/M/L"
```



3. **不可变字符串**

不能修改Java字符串中的字符，因此String类对象被称为不可变字符串。

可以修改字符串变量，让它引用另外一个字符串。

优点是可以让字符串共享。



4. **检测字符串是否相等**

可以使用equals检测两个字符串是否相等。

检测两个字符串是否相等，而不区分大小写，可以使用equalsIgnoreCase方法。

使用==只能确定两个字符串是否放在同一个位置上。

只有字符串常量是共享的，+或substring产生的结果不是共享的。



5. **空串和Null串**

空串""是长度为0的字符串。

检查空串：

```java
if(str.length() == 0)

if(str.equals(""))
```

检查是否为null

```java
if(str == null)
```



6. **码点与代码单元**（没看）



7. **String API**

常用方法：查表



8. **构建字符串**

采用字符串连接每次都会构建新的String对象，效率较低，可以使用StringBuilder类

```java
StringBuilder builder = new StringBuilder();
builder.append(ch); //增加一个char字符
builder.append(str);
String completedString = builder.toString();
```

在需要构建字符串的时候，使用toString方法



## 3.7 输入输出

1. **读取输入**

输出使用System.out.println即可

想要通过控制台进行输入时，首先需要构造一个Scanner对象，并与标准输入流System.in关联，即可使用Scanner类的方法输入：

```java
Scanner in = new Scanner(System.in);
String name = in.nextLine();
String firstName = in.next();
```



2. **格式化输出**

Java沿用了C语言库函数中的printf方法。

```java
System.out.printf("%8.2f", x);
```



以%字符开始的格式说明符都用相应的参数替换。

格式说明符尾部的转换符将指示被格式化的数值类型：f表示浮点数，s表示字符串，d表示十进制整数。

| 转换符 |         类型         |
| :----: | :------------------: |
|   d    |      十进制整数      |
|   x    |     十六进制整数     |
|   o    |      八进制整数      |
|   f    |      定点浮点数      |
|   e    |      指点浮点数      |
|   g    |      通用浮点数      |
|   a    |    十六进制浮点数    |
|   s    |        字符串        |
|   c    |         字符         |
|   b    |        布尔值        |
|   h    |        散列码        |
|   tx   |       日期时间       |
|   %    |        百分号        |
|   n    | 与平台有关的行分隔符 |



还可以给出控制格式化输出的各种标志。

|       标志        |          目的          |
| :---------------: | :--------------------: |
|         +         |  打印正数和负数的符号  |
|       空格        |   在正数之前添加空格   |
|         -         |         左对齐         |
|         (         |    将负数括在括号内    |
|         ,         |     添加分组分隔符     |
|  #（对于f格式）   |       包含小数点       |
| #（对于x或0格式） |     添加前缀0x或0      |
|         $         | 给定被格式化的参数索引 |
|         <         |  格式化前面说明的数值  |
|         0         |      数字前面补0       |
|                   |                        |



可以使用静态的String.Format方法创建一个格式化的字符串，而不打印输出：

```java
String message = String.format("Hello, %s. Next year, you 'll be %d", name, age);
```



3. **文件输入与输出**

要想对文件进行读取，需要用File对象构造一个Scanner对象

```java
Scanner in = new Scanner(Paths.get("myfile.txt"), "UTF-8");
```

若文件名中包含反斜杠/，需要在反斜杠之前再加一个额外的反斜杠。



要想写入文件，需要构造一个PrintWrite对象。

```java
PrintWrite out = new PrintWrite("myfile.txt", "UTF-8");
```

若文件不存在则创建文件。



## 3.8 控制流程

1. **块作用域**

不能在嵌套的两个块中声明同名变量。



2. **条件语句**

```java
if(a > 1)
{...}
else if(a > 0.5)
{...}
else
{...}
```



3. **循环**

条件为true时，while循环执行语句块中内容，开始为false一次也不执行。



4. **确定循环**

for语句第一部分用于对计数器的初始化，第二部分给出每次循环前要检测的循环条件；第三部分指示如何更新计数器。

在for语句内部定义一个变量，这个变量不能在循环体之外使用。



5. **多重选择：switch语句**

```java
switch(choice)
{
    case 1:
        ...
        break;
    case 2:
        ...
        break;
    default:
        ...
        break;
}
```



case标签可以是：

* 类型为char、byte、short或int的常量表达式
* 枚举常量
* 字符串字面量



6. **中断控制语句**

break用于退出循环语句。

continue语句将控制转移到最内层循环的首部。用于for循环可以跳到更新部分。



## 3.9 大数值

java.math包中的BigInteger和BigDecimal，这两个类可以处理包含任意长度数字序列的数值。

BigInteger实现了任意精度的整数运算，BigDecimal实现了任意精度的浮点数运算。



使用静态的方法可以将普通数值转为大数值

不能用+或*等处理大数值，需要使用add和multiply方法

```java
BigInteger a = BigInteger.valueOf(100);
BigInteger c = a.dd(b);
BigInteger d = c.multiply(b.add(BigInteger.valueOf(2)));
```



##  3.10 数组

存储同一类型值的集合，可以通过整型下标访问数组中的每一个值。

创建数组：

```java
int[] a = new int[100];
```



要想获取数组中元素个数，可以使用array.length，数组大小无法改变。



1.**for each循环**

定义一个变量暂存集合中的每一个元素：

```java
for(int element : a)
    System.out.println(element);
```



2. **数组初始化及匿名数组**

```java
int[] smallPrimes = {2,3,5}; //数组初始化简化书写形式
new int[] {11,12,13}; //初始化匿名数组
```



3.**数组拷贝**

Java允许将一个数组变量拷贝给另一个数组变量，两个变量将引用同一个数组。

若希望将 一个数组的所有值拷贝到一个新的数组中去， 就要使用 Arrays 类的 copyOf方法：

```java
int[] newArray = Arrays.copyOf(oldArray, oldArray.length);
```



4. **命令行参数**

每个Java应用都有一个带 String arg[]参数的 main 方法。

接收一个字符串数组，也就是命令行参数。



5. **数组排序**

要想对数值型数组进行排序， 可以使用 Arrays 类中的 sort 方法。

该方法使用了优化的快速排序算法。



6. **多维数组**

多维数组将使用多个下标访问数组元素。

例：

```java
double balances = new double[100][100];
int[][] magicSquare = 
{
    {16,3,2},
    {5,10,11},
    {4,15,14}
};
```



7. **不规则数组**

java没有多维数组，只有一维数组，多维数组被解释为数组的数组。



#  第四章   对象与类

## 4.1 面向对象程序设计概述

1. **类**

类(class)是构造对象的模板或蓝图。

由类构造对象的过程称为创建类的实例。



对象中的数据称为实例域， 操纵数据的过程称为方法。

对每个特定的对象，都有一组特定的实例域值。



实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。

在扩展一个已有的类时，这个扩展后的新类具有所扩展的类的全部属性和方法，该过程称为继承。



2. **对象**

每个对象都保存着描述当前特征的信息，即对象的状态。

除了对象的状态，每个对象都有一个唯一的身份。



3. **识别类**

识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。



4. **类之间的关系**

类之间，最常见的关系有：

* 依赖，uses-a
* 聚合，has-a
* 继承，is-a



如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。

应该尽可能地将相互依赖的类减至最少。

聚合关系意味着类A的对象包含类B的对象。

一般而言，如果类A扩展类B，类A不但包含从类B继承的方法，还会拥有一些额外的功能。



## 4.2 使用预定义类

1. **对象与对象变量**

在Java中，使用构造器构造新实例。

造器是一种特殊的方法，用来构造并初始化对象。

==构造器的名字应该与类名相同==



一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。



2. **LocalDate类**

Java包含两个类：一个是用来表示时间点的Date类；另一个是用来表示大家熟悉的日历表示法的LocalDate类。

不要使用构造器来构造LocalDate类的对象。实际上，应当使用静态工厂方法代表你调用构造器。

如：

```java
LocalDate newYearsEve = LocalDate.of(1999, 12, 31);
```



3. **更改器方法与访问器方法**

调用更改器方法后，对象的状态会改变。

访问器方法只访问对象，而不修改对象。



## 4.3 用户自定义类

要想创建一个完整的程序，应该将若干类组合在一起，其中只有一个类有main方法。



1. **Employee类**

文件名必须与public类的名字相匹配。

在一个源文件中，只能有一个公有类，但可以有任意数目的非公有类。



2. **从构造器开始**

构造器与类同名。

在构造类的对象时，构造器会运行，以便将实例域初始化为所希望的状态。



构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。



构造器：

* 与类同名
* 类可以有一个以上的构造器
* 可以有任意个参数
* 没有返回值
* 总是伴随着new操作一起调用



3. **隐式参数和显式参数**

出现在方法名前的对象为隐式参数，方法名后面括号中的数值为显式参数。

在每一种方法中，==this==表示隐式参数。

Java中，所有方法都必须定义在类的内部定义。



4. **封装的优点**

有时需要获得或设置实例域的值，应提供一下三项内容：

* 一个私有的数据域
* 一个公有的域访问器方法
* 一个公有的域更改器方法



好处：

* 改变内部实现，不会影响其他代码
* 更改器方法可以执行错误检查，如是否小于0



若要返回一个可变对象的引用，应首先对它进行克隆

```java
class Employee
{
    public Date getHireDay()
    {
        return (Date) hireDay.clone();
    }
}
```



5. **基于类的访问权限**

一个方法可以访问所属类的所有对象的私有数据。



6. **私有方法**

在实现一个类时，由于公有数据非常危险，所以应该将所有的数据域都设置为私有的。

大多数方法设计为公有的，某些情况下也可以设为私有。



只要方法是私有的，类的设计者就可以确信：它不会被外部的其他类操作调用，可以将其删去。

如果方法是公有的，就不能将其删去，因为其他的代码很可能依赖它。



7. **final实例域**

可以将实例域定义为final，构建对象时必须初始化这样的域。

且在后面操作中，不能再对它进行修改。

final修饰符大都应用于基本类型域，或不可变类的域。



## 4.4 静态域与静态方法

1. **静态域**

如果将域定义为static，每个类中只有一个这样的域。

每一个对象对于所有的实例域却都有自己的一份拷贝。

它属于类，而不属于任何独立的对象。



2. **静态常量**

静态变量使用得比较少，但静态常量却使用得比较多。

```java
public class Math
{ public static final double PI = 3.14159; }
```



3. **静态方法**

静态方法是一种不能向对象实施操作的方法。例如：

```java
Math.pow(x, a);
```



在运算时，不使用任何Math对象。换句话说，没有隐式的参数。

静态方法不能访问实例域，因为它不能操作对象。但是，静态方法可以访问自身类中的静态域。



在下面两种情况使用静态方法：

*  一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow）
*  一个方法只需要访问类的静态域（例如：Employee.getNextId）。



4. **工厂方法**

静态方法还有另外一种常见的用途。类似LocalDate和NumberFormat的类使用静态工厂方法（factory method）来构造对象。

不利用构造器的原因有两个：

* 无法命名构造器。构造器名字必须与类名相同，有时候希望采用不同的名字。
* 使用构造器时，无法改变所构造的对象类型。



5. **main方法**

main方法也是一个静态方法。

静态的main方法将执行并创建程序所需要的对象。

每个类可以有一个main方法。



## 4.5 方法参数

按值调用表示方法接收的是调用者提供的值。

而按引用调用表示方法接收的是调用者提供的变量地址。



一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。



Java程序设计语言总是采用按值调用。

方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。



方法参数共有两种类型：

* 基本数据类型（数字、布尔值）
* 对象引用



总结：

* 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。
*  一个方法可以改变一个对象参数的状态。
*  一个方法不能让对象参数引用一个新的对象。



## 4.6 对象构造

1. **重载**

如果多个方法有相同的名字、不同的参数，便产生了重载。

编译器必须挑选出具体执行哪个方法。



2. **默认域初始化**

如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值：数值为0、布尔值为false、对象引用为null。



3. **无参数的构造器**

很多类都包含一个无参数的构造函数，对象由无参数构造函数创建时，其状态会设置为适当的默认值。

若编写类时没有编写构造器，那么会提供一个无参数构造器。

若提供了构造器，但没有提供无参数构造器，构造对象时若没有提供参数则不合法。



4. **显式域初始化**

通过重载类的构造器方法，可以采用多种形式设置类的实例域的初始状态。

在执行构造器之前，先执行赋值操作。



5. **参数名**

* 可以在每个参数前面加上一个前缀a。
* 使用this关键字将参数和实例域分开。



6. **调用另一个构造器**

如果构造器的第一个语句形如this(...)，这个构造器将调用同一个类的另一个构造器。

```java
public Employee(double s)
{
    this("Employee #" + nextId, s);
}
```



7. **初始化块**

除在构造器中设置值、在声明中赋值外，还可以使用初始化块进行初始化数据域。

首先运行初始化块才运行构造器主体部分。

```java
class Employee
{
    {
        //初始化块
    }
    
    //构造器
    public Employee()
    {}
}
```



8. **对象析构与finalize方法**

Java不需要人工回收内存。

对象用完时，可以用一个close方法来完成相应的清理操作。



## 4.7 包

Java允许使用包将类组织起来。

使用包的主要原因是确保类名的唯一性。



1. **类的导入**

一个类可以使用所属包中的所有类，以及其他包中的公有类。



两种方式访问另一个包中的共有类：

* 每个类名前添加完整包名
* 使用import语句导入一个特定的类或整个包

使用*只能导入一个包。



2. **静态导入**

import语句不仅可以导入类，还增加了导入静态方法和静态域的功能。

例如：

```java
import static java.lang.System.*;

//可以直接使用System类的静态方法和静态域，不必加类名前缀
out.println("Goodbye");
```



3. **将类放入包中**

要想将一个类放入包中，就必须将包的名字放在源文件的开头，包中定义类的代码之前。

```java
package com.horstmann.corejava;

public class Employee
{
    ...
}
```



4. **包作用域**

标记为public的部分可以被任意的类使用。

标记为private的部分只能被定义它们的类使用

如果没有指定public或private，这个部分（类、方法或变量）可以被同一个包中的所有方法访问。



因此变量必须显式地标记为private，不然的话将默认为包可见。



## 4.8 类路径

类存储在文件系统的子目录中。类的路径必须与包名匹配。

类文件也可以存储在JAR(Java归档)文件中。

在程序中用到第三方的库文件时，通常会给出一个或多个需要包含的JAR文件。



==未完成==



# 第五章   继承

利用继承，人们可以基于已存在的类构造一个新类。

继承已存在的类就是复用（继承）这些类的方法和域。

在此基础上，还可以添加一些新的方法和域，以满足新的需求。



反射是指在程序运行期间发现更多的类及其属性的能力。



## 5.1 类、超类和子类

1. **定义子类**

关键字extends表示继承。

```java
public class Manager extends Employee
{
    
}
```



* 已存在的类称为超类、基类或父类
* 新类称为子类、派生类或孩子类



子类比超类拥有的功能更加丰富。

因此在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。



2. **覆盖方法**

超类中的有些方法对子类并不一定适用。

为此，需要提供一个新的方法来覆盖超类中的这个方法



使用super调用超类中的方法：

```java
super.getSalary();
```



3. **子类构造器**

```java
public Manager(String name,double salary,int year,int month,int day)
{
    super(name, salary, year, month, day);
    bonus = 0;
}
```

这里的super指调用超类的构造器。

使用super调用构造器的语句必须是子类构造器的第一条语句。
